# php-mysql-performance-training

## ◆目的

* 某会社さんの新人研修の一環でパフォーマンスに関する講義をするためのサンプルプロジェクトです
  * PHPとMySQLによる簡単な外部API通信処理と検索画面を用意する
  * その中でAPI通信の実行時間やDB検索処理の速度に着目してみる
* お試しプロジェクトなのでかなり雑なのはごめんなさい

## ◆アプリケーション概要

* 国内の銀行情報と各銀行の支店情報を外部APIから取得してデータベースに登録する
  * 統一金融機関コードデータセット：https://zengin-code.github.io/
    * 銀行情報：https://zengin-code.github.io/api/banks.json
    * 支店情報：https://zengin-code.github.io/api/branches/0001.json
  * テーブル
    * 銀行情報：t_banks
    * 支店情報：t_branches
  * 取得方法とDB登録方法
    * PHPのcurlで銀行情報と支店情報を取得する
    * 取得した情報をPDOでMySQLに登録する
* データベースに登録した情報を検索できるようにする簡単なHTML画面をPHPで実装する

※データフロー

```
外部API -> [取得処理] -> MySQL -> [検索画面] -> 利用者
```

## ◆環境

### 起動

```
make upb
(or)
make up
```

### 停止

```
make down
```

### コンテナに入る方法

```
make app
make db
```

### MySQLに入る方法

```
make mysql
```

* 本来パスワードをgitで平文管理することははセキュリティの観点から望ましくないですが、今回はサンプルのため記載しています
* ユーザーとパスワードはdocker-compose.ymlで定義されているものです

### トップページ

http://localhost:8001

## ◆アプリケーションの実行時間について気にしなければならないこと

* 通常のDB検索や検索結果の整形処理とは違い外部API通信をする場合、インターネットを介して情報のやり取りをするため実行時間が多くなります
  * DB検索して画面に表示する処理の例
    * DB検索：0.01秒（サーバーは違っても内部通信なのでそこそこ早い）
    * HTML生成：0.001秒（サーバーが計算してHTMLを作るだけ）
    * 合計：0.011秒
  * 外部APIに通信した結果でDB検索して画面に表示する処理の例
    * 外部API通信：1.000秒（みんながいつもネットで検索したりするのと同じこと）
    * DB検索：0.01秒（サーバーは違っても内部通信なのでそこそこ早い）
    * HTML生成：0.001秒（サーバーが計算してHTMLを作るだけ）
    * 合計：1.011秒
  * 1秒の待ち時間って？？
    * 1秒なら耐えられるけど、ユーザーにとってはページが早く表示されるに越したことはないです
    * これが5秒などになってくるとユーザーはイライラしてきます
    * イライラすると良くないことが起こります
      * ユーザーの離脱（サービスを使ってくれません）
      * SEOへの悪影響（Googleのランキングが下がります）
      * システム負荷（同時実行数の増加によるCPUやメモリへの負担が増えてしまい最悪はサーバーダウンします）
      * ユーザーがパソコンをぶん投げる（サーバーのせいでパソコンは悪くないのにとばっちりです）
* 外部API通信に限らずDB処理や膨大なループ処理でもアプリケーションの実行時間が多くなる場合があります
  * データの量が膨大
  * 無駄なループ処理など
  * その他にもユーザーの増加によってアクセスが増えることでも実行時間が多くなります（サーバーが忙しくなるため）
* 実際に見てみよう
  * [同期処理による外部API通信](docker/app/src/import-sync.php)
  * [非同期処理による外部API通信](docker/app/src/import-async.php)

## ◆SQLメモ

### レコードをコピーする

```
INSERT INTO t_branches(bank_code, code, name, kana, hira, roma) SELECT 'A001', code, name, kana, hira, roma FROM t_branches;
```

* 「セレクトインサート」と呼ばれるINSERT文です
* SELECTした内容をそのままINSERTすることができます
* 今回は大量レコードを作るために使います

### 実行計画

```
EXPLAIN SELECT * FROM t_branches WHERE roma = 'funabashi';
```

* SQLの性能を確認するときに通常のSQL文の前に「EXPLAIN」をつけます
* 結果の見方はそこそこ熟練が必要です
* 開発や運用をしていて画面表示が遅い時などに、実行されているSQLをEXPLAINして性能の良し悪しを確かめます
* その結果に応じてSQLチューニングやインディックスを設定するなどの対策をしますが、対策方法はEXPLAINの結果次第なのでマニュアルはありません（臨機応変に根気と熟練が必要）
* SQLチューニングやインディックス設定でも解決できない場合はテーブル設計の見直しやアプリケーションの改修を行います

### インディックス追加

```
ALTER TABLE t_branches ADD INDEX test (roma);
```

* MySQLに限らず各種RDBに搭載されている、いわゆる「索引」といった概念です
* 本を読むときに目次を見て知りたいページ番号を探すのと同じです
* RDBも検索時に索引があると、SQLで要求された検索条件に合致する結果を索引から調べてすぐに返事をすることができるようになります

## ◆（まとめ）パフォーマンスの配慮について

* 可能な範囲で並列処理にする
* DB処理ではクエリチューニングやインディックス設定を適切に行う
  * 開発時はローカル環境の少ないデータでも、本番環境では実際に何件くらいかを意識して開発しましょう
* ミドルウエアの見直し（データベースはRDBだけが全てではない）
* キャッシュを利用する
* 重い処理はバッチなどで行う
* レイジーロード
* ロードバランシング・スケール
* 札束で殴る（超絶リッチなスペックのサーバーにする）
